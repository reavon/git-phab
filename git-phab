#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# PYTHON_ARGCOMPLETE_OK
#
# git-phab - git subcommand to integrate with phabricator
#
# Copyright (C) 2008  Owen Taylor
# Copyright (C) 2015  Xavier Claessens <xavier.claessens@collabora.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, If not, see
# http://www.gnu.org/licenses/.

import tempfile
import subprocess
import argparse
import argcomplete
import git
import os
import re
import sys
import json
from urllib.parse import urlsplit, urlunsplit


class Colors(object):
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'


class GitPhab:
    def __init__(self):
        self.task = None
        self.remote = None
        self.assume_yes = False
        self.revision_range = None
        self.reviewers = None
        self.remote_from_config = False
        self.extra_projects = None

    # Copied from git-bz
    def die(self, message):
        print(message, file=sys.stderr)
        sys.exit(1)

    # Copied from git-bz
    def prompt(self, message):
        try:
            while True:
                # Using print here could result in Python adding a stray space
                # before the next print
                sys.stdout.write(message + " [yn] ")
                if self.assume_yes:
                    sys.stdout.write("y\n")
                    sys.stdout.flush()
                    return True
                sys.stdout.flush()
                line = sys.stdin.readline().strip()
                if line == 'y' or line == 'Y':
                    return True
                elif line == 'n' or line == 'N':
                    return False
        except KeyboardInterrupt:
            # Ctrl+C doesn’t cause a newline
            sys.stdout.write("\n")
            return False

    # Copied from git-bz
    def edit_file(self, filename):
        editor = self.repo.git.var("GIT_EDITOR")
        process = subprocess.Popen(editor + " " + filename, shell=True)
        process.wait()
        if process.returncode != 0:
            die("Editor exited with non-zero return code")

    # Copied from git-bz
    def edit_template(self, template):
        # Prompts the user to edit the text 'template' and returns list of
        # lines with comments stripped

        handle, filename = tempfile.mkstemp(".txt", "git-phab-")
        f = os.fdopen(handle, "w")
        f.write(template)
        f.close()

        self.edit_file(filename)

        with open(filename, 'r') as f:
            return [l for l in f.readlines() if not l.startswith("#")]

    def create_task(self):
        task_infos = None
        while not task_infos:
            task_infos = self.edit_template(
                "\n"
                "# Merge branch: %s\n"
                "# Please enter a task title and description for the merge "
                "request" % self.repo.active_branch.name)

        description = ""
        title = task_infos[0]
        if len(task_infos) > 1:
            description = '\n'.join(task_infos[1:])

        reply = self.conduit("maniphest.createtask", {
            "title": title,
            "description": description,
            "projectPHIDs": self.project_phids,
        })

        return reply

    def task_from_branchname(self, bname):
        m = re.search('(^T[0-9]+)($|-.*)', bname)
        return m.group(1) if m else None

    def get_commits(self):
        try:
            # See if the argument identifies a single revision
            commits = [self.repo.rev_parse(self.revision_range)]
        except:
            # If not, assume the argument is a range
            try:
                commits = list(self.repo.iter_commits(self.revision_range))
            except:
                # If not again, the argument must be invalid — perhaps the user
                # has accidentally specified a bug number but not a revision.
                commits = []

        if len(commits) == 0:
            self.die("'%s' does not name any commits. Use HEAD to specify "
                     "just the last commit" % self.revision_range)

        return commits

    def get_differential_link(self, commit):
        m = re.search('(^Differential Revision: )(.*)$',
                      commit.message, re.MULTILINE)
        return None if m is None else m.group(2)

    def get_differential_id(self, commit):
        link = self.get_differential_link(commit)
        return int(link[link.rfind('/') + 2:]) if link else None

    def format_commit(self, commit, status=None):
        diff_id = self.get_differential_id(commit)
        diff_str = "D%s" % diff_id if diff_id else "N/A"

        result = u"%s %s" % (commit.hexsha[:7], diff_str)
        if status:
            result += u" — %s%s%s" % (
                Colors.OKGREEN if status == "Accepted" else Colors.WARNING,
                status,
                Colors.ENDC)

        return result + u" — %s" % commit.summary

    def print_commits(self, commits):
        ids = []
        for c in commits:
            diffid = self.get_differential_id(c)
            if diffid:
                ids.append(diffid)

        reply = self.conduit('differential.query', {"ids": ids})

        if reply["error"]:
            print("Could not get informations about differentials status")
            statuses = None
        else:
            statuses = {}
            for diff in reply["response"]:
                statuses[int(diff["id"])] = diff["statusName"]

        for c in commits:
            status = None
            if statuses:
                status = statuses.get(self.get_differential_id(c),
                                      "Not proposed yet")
            print(self.format_commit(c, status))

    def conduit(self, cmd, params):
        data = bytes(json.dumps(params), 'utf-8')
        output = subprocess.check_output('arc call-conduit ' + cmd,
                                         input=data,
                                         shell=True)
        return json.loads(output.decode('utf-8'))

    def get_wip_branch(self):
        return "wip/phab/" + self.task

    def get_projects_phids(self, projects):
        if self.extra_projects:
            projects.extend(self.extra_projects.split(','))

        reply = self.conduit("project.query", {"names": projects})
        self.project_phids = [phid for phid in
                              reply["response"]["data"].keys()]
        if len(projects) != projects:
            proj_names = [p["name"] for p in
                          reply["response"]["data"].values()]
            for project in projects:
                if project not in proj_names:
                    self.die("%sProject `%s` doesn't seem to exist%s" %
                             (Colors.FAIL, project, Colors.ENDC))

    def validate_args(self):
        self.repo = git.Repo(os.getcwd(), search_parent_directories=True)

        path = os.path.join(self.repo.working_tree_dir, '.arcconfig')
        with open(path) as f:
            self.arcconfig = json.load(f)

        default_projects = []
        try:
            self.phabricator_uri = self.arcconfig["phabricator.uri"]
            default_projects.append(self.arcconfig["project"])
        except KeyError as e:
            self.die("Could not find '%s' in .arcconfig.\n"
                     "Make sure the current repository is properly configured "
                     "for phabricator" % e.args[0])

        # Remove trailing '/' if any
        if self.phabricator_uri[-1] == '/':
            self.phabricator_uri = self.phabricator_uri[:-1]

        self.get_projects_phids(default_projects)

        # Ensure user has setup git-phab before first usage
        try:
            config_remote = self.repo.config_reader().get_value(
                'phab', 'remote')
        except:
            self.die("** Please configure git-phab before first usage.\n\n"
                     " - Set the remote to be used to push your branches for "
                     "review (e.g. 'origin').\n"
                     "       git config phab.remote <remote>\n")

        if not self.remote:
            self.remote = config_remote
            self.remote_from_config = True

        # Validate that self.remote exists
        try:
            remote = self.repo.remote(self.remote)
        except:
            self.die("%s not a valid remote. Aborting." % self.remote)

        # Make sure the user knows what he's doing if the remote's fetch URL is
        # using ssh, otherwise reviewers might not be able to pull their
        # branch.
        url = urlsplit(remote.config_reader.get('url'))
        if url.scheme in ["ssh", "git+ssh"]:
            try:
                force_ssh = self.repo.config_reader().get_value(
                    'phab', 'force-ssh-remote')
            except:
                force_ssh = False

            if not force_ssh:
                ret = self.prompt(
                    "The configured phab.remote (%s) is using ssh.\n"
                    "It means it might not be readable by some people.\n"
                    "Are you sure you want to continue?" % self.remote)
                if ret:
                    writer = self.repo.config_writer()
                    writer.set_value('phab', 'force-ssh-remote', True)
                    writer.release()
                else:
                    pushurl = urlunsplit(url)
                    fetchurl = urlunsplit(url._replace(scheme='git'))
                    self.die("To reconfigure your remote, run:\n"
                             "  git remote set-url {0} {1}\n"
                             "  git remote set-url --push {0} {2}"
                             .format(self.remote, fetchurl, pushurl))

        # Try to guess the task from branch name
        self.branch_name = str(self.repo.head.reference)
        self.branch_task = self.task_from_branchname(self.branch_name)

        if not self.task:
            self.task = self.branch_task

        # Validate the self.task is in the right format
        if self.task and not re.fullmatch('T[0-9]+', self.task):
            self.die("Task '%s' is not in the correct format. "
                     "Expecting 'T123'." % self.task)

        if not self.revision_range:
            tracking = self.repo.head.reference.tracking_branch()
            if not tracking:
                self.die("There is no tracking information for the current "
                         "branch.\n"
                         "Please specify the patches you want to attach by "
                         "setting the <revision range> \n\n"
                         "If you wish to set tracking information for this "
                         "branch you can do so with: \n"
                         "  git branch --set-upstream-to <remote>/<branch> %s"
                         % self.branch_name)
            self.revision_range = str(tracking) + '..'
            print("Using revision range '%s'" % self.revision_range)

        if not self.reviewers:
            self.reviewers = self.arcconfig.get("default-reviewers")

    def parse_commit_msg(self, msg):
        subject = None
        body = []
        fields = []

        for line in msg.split('\n'):
            if not subject:
                subject = line
            elif line.startswith('Differential Revision: '):
                fields.append(line)
            else:
                body.append(line)

        return subject, body, fields

    def replace_fields(self, string):
        # This is the list of fields phabricator will search by default in
        # commit messages. Case insensitive.
        fields = ['title:', 'summary:', 'test plan:', 'testplan:', 'tested:',
                  'tests:', 'reviewer:', 'reviewers:', 'reviewed by:', 'cc:',
                  'ccs:', 'subscriber:', 'subscribers:', 'project:',
                  'projects:', 'maniphest task:', 'maniphest tasks:',
                  'differential revision:', 'conflicts:', 'git-svn-id:',
                  'auditors:']

        for field in fields:
            field_ = field[:-1] + '_:'
            string = re.sub(field, field_, string, flags=re.I)

        return string

    def do_attach(self):
        if self.repo.is_dirty():
            self.die("Repository is dirty. Aborting.")

        # If we are in branch "T123" and user does "git phab attach -t T456",
        # that's suspicious. Better stop before doing a mistake.
        if self.branch_task and self.branch_task != self.task:
            self.die("Your current branch name suggests task %s but you're "
                     "going to attach to task %s. Aborting."
                     % (self.branch_task, self.task))

        summary = ""

        # Oldest commit is last in the list
        commits = self.get_commits()
        s = commits[-1].hexsha + "^..HEAD"
        all_commits = list(self.repo.iter_commits(s))

        # Sanity checks
        for c in commits:
            if c not in all_commits:
                self.die("'%s' is not in current tree. Aborting." % c.hexsha)
            if len(c.parents) > 1:
                self.die("'%s' is a merge commit. Aborting." % c.hexsha)

        # Ask confirmation before doing any harm
        self.print_commits(commits)

        if not self.task:
            if self.prompt("Create a task for above commits?"):
                try:
                    self.task = self.create_task()["response"]["objectName"]
                    summary += "New: task %s\n" % self.task
                except KeyError:
                    self.die("Could not create task.")

        if not self.prompt("Attach above commits?" if not self.task else
                           "Attach above commits to task %s?" % self.task):
            print("Aborting")
            sys.exit(0)

        orig_commit = self.repo.head.commit
        orig_branch = self.repo.head.reference

        options = ['--allow-untracked',
                   '--config history.immutable=false',
                   '--verbatim']
        if self.reviewers:
            options.append('--reviewers ' + self.reviewers)
        if self.message:
            options.append('--message "' + self.message + '"')
        arc_cmd = 'arc diff %s HEAD~1' % (' '.join(options))

        arc_failed = False
        try:
            # Detach HEAD from the branch; this gives a cleaner reflog for the
            # branch
            print("Moving to starting point")
            self.repo.head.reference = commits[-1].parents[0]
            self.repo.head.reset(index=True, working_tree=True)

            last_revision_id = None
            for commit in reversed(all_commits):
                self.repo.git.cherry_pick(commit.hexsha)

                if not arc_failed and commit in commits:
                    # Add extra info in the commit msg. It is important that
                    # phabricator fields are last, after all common git fields
                    # like 'Reviewed-by:', etc. Note that "Depends on" is not a
                    # field and is parsed from the body part.
                    orig_commit = self.repo.head.commit
                    subject, body, fields = self.parse_commit_msg(
                        commit.message)
                    if last_revision_id:
                        body.append("Depends on %s" % last_revision_id)
                    if self.task:
                        fields.append("Maniphest Tasks: %s" % self.task)
                    fields.append("Projects: %s" %
                                  ','.join(self.project_phids))

                    subject = self.replace_fields(subject.strip())
                    body = self.replace_fields('\n'.join(body).strip())
                    fields = '\n'.join(fields).strip()
                    msg = '\n\n'.join([subject, body, fields])

                    self.repo.head.commit = self.repo.head.commit.parents[0]
                    self.repo.head.commit = self.repo.index.commit(msg)

                    print("attach " + commit.hexsha)
                    try:
                        subprocess.check_call(arc_cmd, shell=True)
                    except:
                        print("Command '%s' failed. Finnish rebuilding branch "
                              "without proposing further patches" % arc_cmd)
                        arc_failed = True
                        self.repo.head.commit = orig_commit
                        summary += "Failed proposing: %s -- " \
                            "NO MORE PATCH PROPOSED\n" % self.format_commit(
                                self.repo.head.commit)
                        continue

                    # arc diff modified our commit message. Re-commit it with
                    # the original message, adding only the
                    # "Differential Revision:" line.
                    msg = commit.message
                    orig_link = self.get_differential_link(commit)
                    new_link = self.get_differential_link(
                        self.repo.head.commit)
                    if orig_link is None and new_link is not None:
                        msg = msg + '\nDifferential Revision: ' + new_link
                        summary += "New: "
                    else:
                        summary += "Updated: "

                    self.repo.head.commit = self.repo.head.commit.parents[0]
                    self.repo.head.commit = self.repo.index.commit(msg)
                    last_revision_id = new_link.split("/")[-1]

                    summary += self.format_commit(self.repo.head.commit) + "\n"
                else:
                    print("pick " + commit.hexsha)
                    summary += "Picked: %s\n" % self.format_commit(commit)

            if orig_branch is not None:
                orig_branch.commit = self.repo.head.commit
                self.repo.head.reference = orig_branch
        except:
            print("Cleaning up back to original state on error")
            self.repo.head.commit = orig_commit
            if orig_branch is not None:
                orig_branch.commit = orig_commit
                self.repo.head.reference = orig_branch
            self.repo.head.reset(index=True, working_tree=True)
            raise

        if self.task and not arc_failed:
            try:
                branch = self.get_wip_branch()
                remote = self.repo.remote(self.remote)
                if self.prompt('Push HEAD to %s/%s?' % (remote, branch)):
                    remote.push('HEAD:refs/heads/' + branch, force=True)
                    summary += "Branch pushed to %s/%s\n" % (remote, branch)

                uri = "%s#%s" % (remote.config_reader.get('url'), branch)
                try:
                    self.conduit('maniphest.update', {
                        "id": int(self.task[1:]),
                        "auxiliary": {
                            "std:maniphest:git:uri-branch": uri
                        }
                    })
                except:
                    print("Failed to set std:maniphest:git:uri-branch to %s"
                          % uri)

            except Exception as e:
                summary += "Failed: push wip branch: %s\n" % e

        if self.task and not self.branch_task:
            # Check if we already have a branch for this task
            branch = None
            for b in self.repo.branches:
                if self.task_from_branchname(b.name) == self.task:
                    branch = b
                    break

            if branch:
                if self.prompt('Reset branch %s to what has just been sent '
                               'to phabricator?' % branch.name):
                    branch.commit = self.repo.head.commit
                    summary += "Branch %s reset to %s" % \
                               (branch.name, branch.commit)
            else:
                new_bname = self.task
                if self.branch_name not in ["master"]:
                    new_bname += '-' + self.branch_name

                if self.prompt('Create and checkout a new branch called: %s?' %
                               new_bname):
                    new_branch = self.repo.create_head(new_bname)
                    new_branch.checkout()
                    summary += "Branch %s created and checked out" % new_bname

        print("\n\nSummary:")
        print(summary)

    def do_log(self):
        commits = self.get_commits()
        self.print_commits(commits)

    def do_fetch(self):
        branch = self.get_wip_branch()
        remote = self.remote

        if self.remote_from_config:
            try:
                reply = self.conduit('maniphest.query', {
                    "ids": [int(self.task[1:])]
                })
                props = list(reply['response'].values())[0]
                uri = props['auxiliary']['std:maniphest:git:uri-branch']
                remote, branch = uri.split('#')
            except:
                print("Couldn't get git URI from Maniphest")

        print("Git URI: %s, branch: %s" % (remote, branch))
        self.repo.git.fetch(remote, "%s:%s" % (branch, self.task), force=True)
        print("Branch %s created." % self.task)

    def do_browse(self):
        urls = []
        if not self.objects:
            if not self.task:
                self.die("Could not figure out a task from branch name")
            self.objects = [self.task]

        for obj in self.objects:
            if re.fullmatch('(T|D)[0-9]+', obj):
                urls.append(self.phabricator_uri + "/" + obj)
                continue

            try:
                commit = self.repo.rev_parse(obj)
            except git.BadName:
                self.die("Wrong commit hash: %s" % obj)

            uri = self.get_differential_link(commit)
            if not uri:
                print("Could not find a differential for %s" % obj)
                continue
            urls.append(uri)

        for url in urls:
            print("Openning: %s" % url)
            subprocess.check_call(["xdg-open", url],
                                  stdout=subprocess.DEVNULL,
                                  stderr=subprocess.DEVNULL)

    def run(self):
        self.validate_args()
        method = 'do_' + self.subparser_name
        getattr(self, method)()


def DisabledCompleter(prefix, **kwargs):
    return []

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Phabricator integration.')
    subparsers = parser.add_subparsers(dest='subparser_name')

    attach_parser = subparsers.add_parser(
        'attach', help="Generate a Differential for each commit")
    attach_parser.add_argument(
        '--reviewers', '-r', metavar='<username1,username2,...>',
        help="A list of reviewers") \
        .completer = DisabledCompleter
    attach_parser.add_argument(
        '--message', '-m', metavar='<message>',
        help=("When updating a revision, use the specified message instead of "
              "prompting")) \
        .completer = DisabledCompleter
    attach_parser.add_argument(
        '--task', '-t', metavar='<T123>',
        help=("Set the task this Differential refers to")) \
        .completer = DisabledCompleter
    attach_parser.add_argument(
        '--remote', metavar='<remote>',
        help=("A remote repository to push to. "
              "Overrides 'phab.remote' configuration.")) \
        .completer = DisabledCompleter
    attach_parser.add_argument(
        '--assume-yes', '-y', dest="assume_yes", action="store_true",
        help="Assume `yes` as answer to all prompts.") \
        .completer = DisabledCompleter
    attach_parser.add_argument(
        '--projects', '-p', dest="extra_projects",
        metavar='<extra_project1,extra_project2,...>', default=None,
        help="A list of `extra` projects (they will be added to"
        "any project(s) configured in .arcconfig)") \
        .completer = DisabledCompleter
    attach_parser.add_argument(
        'revision_range', metavar='<revision range>',
        nargs='?', default=None,
        help="commit or revision range to attach. When not specified, "
             "the tracking branch is used") \
        .completer = DisabledCompleter

    log_parser = subparsers.add_parser(
        'log', help="Show commit logs with their differential ID")
    log_parser.add_argument(
        'revision_range', metavar='<revision range>',
        nargs='?', default=None,
        help="commit or revision range to show. When not specified, "
             "the tracking branch is used") \
        .completer = DisabledCompleter

    fetch_parser = subparsers.add_parser(
        'fetch', help="Fetch a task's branch")
    fetch_parser.add_argument(
        '--remote', metavar='<remote>',
        help=("A remote repository to fetch from. "
              "Overrides 'phab.remote' configuration.")) \
        .completer = DisabledCompleter
    fetch_parser.add_argument(
        'task', metavar='<T123>',
        help="The task to fetch") \
        .completer = DisabledCompleter

    browse_parser = subparsers.add_parser(
        'browse', help="Open the task of the current "
        "branch in web browser")
    browse_parser.add_argument(
        'objects', nargs='*', default=[],
        help="The 'objects' to browse. It can either be a task ID, "
             "a revision ID, a commit hash or empty to open current branch's "
             "task.") \
        .completer = DisabledCompleter

    argcomplete.autocomplete(parser)

    obj = GitPhab()
    parser.parse_args(namespace=obj)
    obj.run()
