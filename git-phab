#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# git-phab - git subcommand to integrate with phabricator
#
# Copyright (C) 2008  Owen Taylor
# Copyright (C) 2015  Xavier Claessens <xavier.claessens@collabora.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, If not, see
# http://www.gnu.org/licenses/.

import tempfile
import subprocess
import argparse
import git
import os
import re
import sys
import json
import configparser
from urllib.parse import urlsplit, urlunsplit


class GitPhab:
    def __init__(self):
        self.task = None
        self.remote = None

    def read_arcconfig(self):
        path = os.path.join(self.repo.working_tree_dir, '.arcconfig')
        with open(path) as f:
            self.arcconfig = json.load(f)


# Copied from git-bz
def die(message):
    print(message, file=sys.stderr)
    sys.exit(1)


# Copied from git-bz
def prompt(message, assume_yes):
    try:
        while True:
            # Using print here could result in Python adding a stray space
            # before the next print
            sys.stdout.write(message + " [yn] ")
            if assume_yes:
                sys.stdout.write(message + ": y\n")
                sys.stdout.flush()
                return True

            sys.stdout.flush()
            line = sys.stdin.readline().strip()
            if line == 'y' or line == 'Y':
                return True
            elif line == 'n' or line == 'N':
                return False
    except KeyboardInterrupt:
        # Ctrl+C doesn’t cause a newline
        sys.stdout.write("\n")
        return False


# Copied from git-bz
def edit_file(filename):
    editor = repo.git.var("GIT_EDITOR")
    process = subprocess.Popen(editor + " " + filename, shell=True)
    process.wait()
    if process.returncode != 0:
        die("Editor exited with non-zero return code")


# Copied from git-bz
def edit_template(template):
    # Prompts the user to edit the text 'template' and returns list of
    # lines with comments stripped

    handle, filename = tempfile.mkstemp(".txt", "git-phab-")
    f = os.fdopen(handle, "w")
    f.write(template)
    f.close()

    edit_file(filename)

    return [l for l in open(filename, "r").readlines()
            if not l.startswith("#")]


def get_commits(commit_or_revision_range):
    try:
        # See if the argument identifies a single revision
        commits = [args.repo.rev_parse(commit_or_revision_range)]
    except:
        # If not, assume the argument is a range
        try:
            commits = list(args.repo.iter_commits(commit_or_revision_range))
        except:
            # If not again, the argument must be invalid — perhaps the user has
            # accidentally specified a bug number but not a revision.
            commits = []

    if len(commits) == 0:
        die(("'%s' does not name any commits. Use HEAD to specify just the "
             "last commit") % commit_or_revision_range)

    return commits


def get_differential_link(commit):
    m = re.search('(^Differential Revision: )(.*)$',
                  commit.message, re.MULTILINE)
    return None if m is None else m.group(2)


def format_commit(commit):
    link = get_differential_link(commit)
    d = "N/A" if link is None else link[link.rfind('/') + 1:]
    return u"%s %s — %s" % (commit.hexsha[:7], d, commit.summary)


def print_commit(commit):
    print(format_commit(commit))


def conduit(cmd, args):
    output = subprocess.check_output('arc call-conduit ' + cmd,
                                     input=bytes(json.dumps(args), 'utf-8'),
                                     shell=True)
    return json.loads(output.decode('utf-8'))


def get_wip_branch(args):
    return "wip/phab/" + args.task


def validate_args(args):
    args.repo = git.Repo(os.getcwd())
    args.read_arcconfig()

    if not hasattr(args, 'revision_range'):
        args.revision_range = None

    # Ensure user has setup git-phab before first usage
    try:
        config_remote = args.repo.config_reader().get_value('phab', 'remote')
    except:
        die("** Please configure git-phab before first usage.\n\n"
            " - Set the remote to be used to push your branches for review "
            "(e.g. 'origin').\n"
            "       git config phab.remote <remote>\n")

    args.remote_from_config = False
    if not args.remote:
        args.remote = config_remote
        args.remote_from_config = True

    # Validate that args.remote exists
    try:
        remote = args.repo.remote(args.remote)
    except:
        die("%s not a valid remote. Aborting." % args.remote)

    # Make sure the user knows what he's doing if the remote's fetch URL is
    # using ssh, otherwise reviewers might not be able to pull their branch.
    url = urlsplit(remote.config_reader.get('url'))
    if url.scheme in ["ssh", "git+ssh"]:
        try:
            force_ssh = \
                args.repo.config_reader().get_value('phab', 'force-ssh-remote')
        except:
            force_ssh = False

        if not force_ssh:
            if prompt("The configured phab.remote (%s) is using ssh.\n"
                      "It means it might not be readable by some people.\n"
                      "Are you sure you want to continue?" % args.remote,
                      args.assume_yes):
                args.repo.config_writer().set_value('phab', 'force-ssh-remote',
                                                    True)
            else:
                pushurl = urlunsplit(url)
                fetchurl = urlunsplit(url._replace(scheme='git'))
                die("To reconfigure your remote, run:\n"
                    "  git remote set-url {0} {1}\n"
                    "  git remote set-url --push {0} {2}"
                    .format(args.remote, fetchurl, pushurl))

    # Try to guess the task from branch name
    if not args.task:
        m = re.search('(^T[0-9]+)($|-.*)', str(args.repo.head.reference))
        if m is not None:
            args.task = m.group(1)

    # Validate the args.task is in the right format
    if args.task and not re.fullmatch('T[0-9]+', args.task):
        die(("Task '%s' is not in the correct format. "
             "Expecting 'T123'." % args.task))

    if not args.revision_range:
        branchname = str(args.repo.head.reference)
        try:
            baseremote = args.repo.config_reader().get_value(
                'branch "%s"' % branchname, "remote")
            basebranch = args.repo.config_reader().get_value(
                'branch "%s"' % branchname, "merge")
            basebranch = basebranch.replace("refs/heads/", "")
            args.revision_range = baseremote + "/" + basebranch + ".."
            print("Revision range set to: %s" % args.revision_range)
        except configparser.NoSectionError:
            die("There is no tracking information for the current branch.\n"
                "Please specify the patches you want to attach setting"
                " the <revision range> \n"
                "See git phab attach --help for details.\n\n"
                "If you wish to set tracking information for this branch you "
                "can do so with: \n\n"
                "  git branch --set-upstream-to <remote>/<branch> %s"
                % branchname)


def parse_commit_msg(msg):
    subject = None
    body = []
    fields = []

    for line in msg.split('\n'):
        if not subject:
            subject = line
        elif line.startswith('Differential Revision: '):
            fields.append(line)
        else:
            body.append(line)

    return subject, body, fields


def get_arcconfig():
    farcconf = os.path.join(repo.git.rev_parse("--show-toplevel"),
                            ".arcconfig")

    try:
        return json.load(open(farcconf))
    except FileNotFoundError:
        return None
    except json.JSONDecodeError:
        return None


def create_task():
    arcconf = get_arcconfig()
    project = None
    if arcconf:
        try:
            project = arcconf["project"]
        except KeyError:
            pass

    while not project:
        project = input("Could not find any project for which "
                        "to create the task please specify one:")

    reply = conduit("project.query", {"names": [project]})
    phids = [phid for phid in reply["response"]["data"].keys()]

    task_infos = None
    while not task_infos:
        task_infos = edit_template("# Merge branch: %s\n\n"
                                   "# Please enter a task title for the "
                                   "merge request" % repo.active_branch.name)

    description = ""
    title = task_infos[0].replace("\n", "")
    if len(title) > 1:
        for s in title[1:]:
            description += s

    return conduit("maniphest.createtask", {"title": title,
                                            "projectPHIDs": phids,
                                            "description": description})


def task_from_branchname():
    name = str(repo.head.reference)
    m = re.search('(^T[0-9]+)($|-.*)', name)
    if m is not None:
        return m.group(1)

    return None


def do_attach(args):
    if args.repo.is_dirty():
        die("Repository is dirty. Aborting.")

    # Oldest commit is last in the list
    commits = get_commits(args.revision_range)
    all_commits = list(args.repo.iter_commits(commits[-1].hexsha + "^..HEAD"))

    # Sanity checks
    for c in commits:
        if c not in all_commits:
            die("'%s' is not in current tree. Aborting." % c.hexsha)
        if len(c.parents) > 1:
            die("'%s' is a merge commit. Aborting." % c.hexsha)

    # Ask confirmation before doing any harm
    for c in commits:
        print_commit(c)

    if not args.task:
        res = input("Specify task or enter 'y' to create a task or "
                    "'n' if you do not want any task to be associated to "
                    "revision(s): ")
        if re.fullmatch('T[0-9]+', res):
            args.task = res
        else:
            try:
                args.task = create_task()["response"]["objectName"]
            except KeyError:
                die("Could not create task.")

    if not prompt("Attach above commits?" if not args.task else
                  "Attach above commits to task %s?" % args.task,
                  args.assume_yes):
        print("Aborting")
        sys.exit(0)

    orig_commit = args.repo.head.commit
    orig_branch = args.repo.head.reference

    options = ['--allow-untracked',
               '--config history.immutable=false',
               '--verbatim']
    if args.reviewers:
        options.append('--reviewers ' + args.reviewers)
    if args.message:
        options.append('--message "' + args.message + '"')
    arc_cmd = 'arc diff %s HEAD~1' % (' '.join(options))

    summary = ""

    try:
        # Detach HEAD from the branch; this gives a cleaner reflog for the
        # branch
        print("Moving to starting point")
        args.repo.head.reference = commits[-1].parents[0]
        args.repo.head.reset(index=True, working_tree=True)

        last_revision_id = None
        for commit in reversed(all_commits):
            args.repo.git.cherry_pick(commit.hexsha)

            if commit in commits:
                # Add extra info in the commit msg. It is important that
                # phabricator fields are last, after all common git fields like
                # 'Reviewed-by:', etc. Note that "Depends on" is not a field
                # and is parsed from the body part.
                subject, body, fields = parse_commit_msg(commit.message)
                if last_revision_id:
                    body.append("Depends on %s" % last_revision_id)
                if args.task:
                    fields.append("Maniphest Tasks: %s" % args.task)

                msg = '\n\n'.join([subject,
                                   '\n'.join(body),
                                   '\n'.join(fields)])

                args.repo.head.commit = args.repo.head.commit.parents[0]
                args.repo.head.commit = args.repo.index.commit(msg)

                print("attach " + commit.hexsha)
                try:
                    subprocess.check_call(arc_cmd, shell=True)
                except:
                    print("Command '%s' failed. Continuing." % arc_cmd)
                    summary += "Failed: %s\n" % format_commit(commit)
                    args.repo.head.commit = commit
                    continue

                # arc diff modified our commit message. Re-commit it with the
                # original message, adding only the "Differential Revision:"
                # line.
                msg = commit.message
                orig_link = get_differential_link(commit)
                new_link = get_differential_link(args.repo.head.commit)
                if orig_link is None and new_link is not None:
                    msg = msg + '\nDifferential Revision: ' + new_link
                    summary += "New: "
                else:
                    summary += "Updated: "

                args.repo.head.commit = args.repo.head.commit.parents[0]
                args.repo.head.commit = args.repo.index.commit(msg)
                last_revision_id = new_link.split("/")[-1]

                summary += format_commit(args.repo.head.commit) + "\n"
            else:
                print("pick " + commit.hexsha)
                summary += "Picked: %s\n" % format_commit(commit)

        if orig_branch is not None:
            orig_branch.commit = args.repo.head.commit
            args.repo.head.reference = orig_branch
    except:
        print("Cleaning up back to original state on error")
        args.repo.head.commit = orig_commit
        if orig_branch is not None:
            orig_branch.commit = orig_commit
            args.repo.head.reference = orig_branch
        args.repo.head.reset(index=True, working_tree=True)
        raise

    if args.task:
        try:
            branch = get_wip_branch(args)
            remote = args.repo.remote(args.remote)
            if prompt('Push HEAD to %s/%s?' % (remote, branch),
                      args.assume_yes):
                remote.push('HEAD:refs/heads/' + branch, force=True)
                summary += "Branch pushed to %s/%s\n" % (remote, branch)

            if not task_from_branchname():
                new_bname = "%s-%s" % (args.task, str(repo.head.reference))
                branch = [b for b in repo.branches if b.name == new_bname]
                if branch:
                    if prompt('Reset branch %s to what has just been sent '
                              'to phabricator?' % new_bname,
                              args.assume_yes):
                        commit = repo.commit().hexsha
                        branch = branch[0]
                        try:
                            branch.checkout()
                            repo.git.reset("--hard", commit)
                        except Exception as e:
                            print("Failed to reset --hard %s on %s (%s)" % (
                                commit, new_bname, e))
                elif prompt('Create a new branch called: %s?' % new_bname,
                            args.assume_yes):
                        try:
                            repo.git.checkout("-b", new_bname)
                        except Exception as e:
                            print("Failed to create branch %s (%s)" % (
                                new_bname, e))

            uri = "%s#%s" % (remote.config_reader.get('url'), branch)
            try:
                conduit('maniphest.update', {
                    "id": int(args.task[1:]),
                    "auxiliary": {
                        "std:maniphest:git:uri-branch": uri
                    }
                })
            except:
                print("Failed to set std:maniphest:git:uri-branch to %s" % uri)

        except Exception as e:
            summary += "Failed: push wip branch: %s\n" % e

    print("\n\nSummary:")
    print(summary)


def do_log(args):
    commits = get_commits(args.revision_range)
    for c in commits:
        print_commit(c)


def do_fetch(args):
    branch = get_wip_branch(args)
    remote = args.remote

    if args.remote_from_config:
        try:
            reply = conduit('maniphest.query', {
                "ids": [int(args.task[1:])]
            })
            props = list(reply['response'].values())[0]
            uri = props['auxiliary']['std:maniphest:git:uri-branch']
            remote, branch = uri.split('#')
        except:
            print("Couldn't get git URI from Maniphest")

    print("Git URI: %s, branch: %s" % (remote, branch))
    args.repo.git.fetch(remote, "%s:%s" % (branch, args.task), force=True)
    print("Branch %s created." % args.task)


def do_browse(args):
    urls = []
    if not args.objects:
        if not args.task:
            die("Could not figure out a task from branch name")
        args.objects = [task]

    for obj in args.objects:
        if re.fullmatch('T[0-9]+', obj) or re.fullmatch('D[0-9]+', obj):
            try:
                urls.append(args.arcconfig["phabricator.uri"] + "/" + obj)
                continue
            except:
                die("Could not find phabricator.uri in .arcconfig.\n"
                    "Make sure the current repository is proporly configured "
                    "for phabricator")

        try:
            commit = args.repo.rev_parse(obj)
        except git.BadName:
            die("Wrong commit hash: %s" % obj)

        uri = get_differential_link(commit)
        if not uri:
            print("Could not find a differential for %s" % obj)
            continue
        urls.append(uri)

    for url in urls:
        print("Openning: %s" % url)
        subprocess.check_call(["xdg-open", url],
                              stdout=subprocess.DEVNULL,
                              stderr=subprocess.DEVNULL)


parser = argparse.ArgumentParser(description='Phabricator integration.')
subparsers = parser.add_subparsers()

attach_parser = subparsers.add_parser(
    'attach', help="Generate a Differential for each commit")
attach_parser.add_argument(
    '--reviewers', '-r', metavar='<username1,username2,...>',
    help="A list of reviewers")
attach_parser.add_argument(
    '--message', '-m', metavar='<message>',
    help=("When updating a revision, use the specified message instead of "
          "prompting"))
attach_parser.add_argument(
    '--task', '-t', metavar='<T123>',
    help=("Set the task this Differential refers to"))
attach_parser.add_argument(
    '--remote', metavar='<remote>',
    help=("A remote repository to push to. "
          "Overrides 'phab.remote' configuration."))
attach_parser.add_argument(
    'revision_range', metavar='<revision range>',
    nargs='?', default='',
    help="commit or revision range to show."
    " When not specified, branch.*.remote configuration "
    "  for the current branch is consulted to determine what"
    " to propose. ")
attach_parser.add_argument(
    '--assume-yes', '-y', dest="assume_yes", action="store_true",
    help="Automatic yes to prompts. "
    "Assume `yes` as answer to all prompts.")
attach_parser.set_defaults(func=do_attach)

log_parser = subparsers.add_parser(
    'log', help="Show commit logs with their differential ID")
log_parser.add_argument(
    'revision_range', metavar='<revision range>',
    nargs='?', default=None,
    help="commit or revision range to show."
    " When not specified, branch.*.remote configuration "
    "  for the current branch is consulted to determine what"
    " to propose. ")
log_parser.set_defaults(func=do_log)

fetch_parser = subparsers.add_parser(
    'fetch', help="Fetch a task's branch")
fetch_parser.add_argument(
    '--remote', metavar='<remote>',
    help=("A remote repository to fetch from. "
          "Overrides 'phab.remote' configuration."))
fetch_parser.add_argument(
    'task', metavar='<T123>',
    help="The task to fetch")
fetch_parser.set_defaults(func=do_fetch)

browse_parser = subparsers.add_parser(
    'browse', help="Open the task of the current "
    "branch in web browser")
browse_parser.add_argument(
    'objects', nargs='*', default=[],
    help="The 'objects' to browse, it can either be a task ID."
    " A revision ID or a commit hash.",)
browse_parser.set_defaults(func=do_browse)

obj = GitPhab()
args = parser.parse_args(namespace=obj)
validate_args(args)
args.func(args)
